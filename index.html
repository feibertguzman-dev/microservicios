<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Microservicios en Ingenier√≠a de Software - Gu√≠a Completa</title>
    <link rel="stylesheet" href="styles.css">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800&display=swap" rel="stylesheet">
</head>
<body>
    <!-- Navigation -->
    <nav class="navbar">
        <div class="container">
            <div class="nav-brand">
                <h2>üî∑ Microservicios</h2>
            </div>
            <ul class="nav-menu">
                <li><a href="#introduccion">Introducci√≥n</a></li>
                <li><a href="#paso-a-paso">Paso a Paso</a></li>
                <li><a href="#arquitecturas">Arquitecturas</a></li>
                <li><a href="#stack-tecnologico">Stack Tecnol√≥gico</a></li>
                <li><a href="#ciclo-vida">Ciclo de Vida</a></li>
                <li><a href="#quiz">Quiz</a></li>
            </ul>
        </div>
    </nav>

    <!-- Hero Section -->
    <section class="hero">
        <div class="container">
            <div class="hero-content">
                <h1 class="hero-title">Microservicios en Ingenier√≠a de Software</h1>
                <p class="hero-subtitle">Una gu√≠a completa para entender, dise√±ar e implementar arquitecturas basadas en microservicios</p>
                <a href="#introduccion" class="btn-primary">Comenzar a Aprender</a>
            </div>
        </div>
    </section>

    <!-- Introducci√≥n -->
    <section id="introduccion" class="section">
        <div class="container">
            <h2 class="section-title">¬øQu√© son los Microservicios?</h2>
            <div class="content-grid">
                <div class="content-text">
                    <p>Los <strong>microservicios</strong> representan un enfoque arquitect√≥nico para el desarrollo de aplicaciones en el cual una aplicaci√≥n grande se construye como un conjunto de servicios modulares y peque√±os. Cada m√≥dulo soporta un objetivo de negocio espec√≠fico y utiliza una interfaz simple y bien definida para comunicarse con otros servicios.</p>
                    
                    <p>A diferencia de la arquitectura monol√≠tica tradicional, donde todos los componentes est√°n estrechamente acoplados y se ejecutan como una √∫nica unidad, los microservicios permiten que cada servicio sea desarrollado, desplegado y escalado de manera independiente. Esta independencia proporciona mayor flexibilidad, resiliencia y facilita la adopci√≥n de nuevas tecnolog√≠as.</p>
                    
                    <h3>Ventajas de los Microservicios</h3>
                    <ul>
                        <li><strong>Escalabilidad independiente:</strong> Cada servicio puede escalarse seg√∫n sus necesidades espec√≠ficas</li>
                        <li><strong>Flexibilidad tecnol√≥gica:</strong> Diferentes servicios pueden usar diferentes tecnolog√≠as</li>
                        <li><strong>Despliegue independiente:</strong> Los servicios pueden actualizarse sin afectar a otros</li>
                        <li><strong>Resiliencia:</strong> El fallo de un servicio no afecta necesariamente a toda la aplicaci√≥n</li>
                        <li><strong>Equipos aut√≥nomos:</strong> Equipos peque√±os pueden trabajar en servicios espec√≠ficos</li>
                    </ul>
                    
                    <h3>Desaf√≠os de los Microservicios</h3>
                    <ul>
                        <li><strong>Complejidad operacional:</strong> Mayor n√∫mero de servicios que gestionar</li>
                        <li><strong>Comunicaci√≥n entre servicios:</strong> Necesidad de gestionar llamadas de red</li>
                        <li><strong>Consistencia de datos:</strong> Transacciones distribuidas son m√°s complejas</li>
                        <li><strong>Testing:</strong> Pruebas de integraci√≥n m√°s complejas</li>
                    </ul>
                </div>
                <div class="content-image">
                    <img src="images/monolithic_vs_microservices.png" alt="Monol√≠tico vs Microservicios">
                    <p class="image-caption">Comparaci√≥n entre arquitectura monol√≠tica y microservicios</p>
                </div>
            </div>
        </div>
    </section>

    <!-- Paso a Paso -->
    <section id="paso-a-paso" class="section section-alt">
        <div class="container">
            <h2 class="section-title">C√≥mo Crear un Microservicio: Gu√≠a Paso a Paso</h2>
            
            <div class="steps-container">
                <div class="step-card">
                    <div class="step-number">1</div>
                    <h3>Identificar el Dominio del Negocio</h3>
                    <p>El primer paso es identificar y delimitar claramente el dominio del negocio que el microservicio va a manejar. Utiliza t√©cnicas como <strong>Domain-Driven Design (DDD)</strong> para identificar bounded contexts. Cada microservicio debe tener una responsabilidad √∫nica y bien definida.</p>
                    <div class="step-details">
                        <strong>Actividades clave:</strong>
                        <ul>
                            <li>Analizar los requisitos del negocio</li>
                            <li>Identificar bounded contexts</li>
                            <li>Definir las responsabilidades del servicio</li>
                            <li>Establecer los l√≠mites del servicio</li>
                        </ul>
                    </div>
                </div>

                <div class="step-card">
                    <div class="step-number">2</div>
                    <h3>Dise√±ar la API del Servicio</h3>
                    <p>Define c√≥mo otros servicios y clientes interactuar√°n con tu microservicio. Dise√±a una API RESTful o utiliza GraphQL seg√∫n tus necesidades. Documenta claramente los endpoints, m√©todos HTTP, formatos de datos y c√≥digos de respuesta.</p>
                    <div class="step-details">
                        <strong>Consideraciones:</strong>
                        <ul>
                            <li>Versionado de API (v1, v2, etc.)</li>
                            <li>Documentaci√≥n con OpenAPI/Swagger</li>
                            <li>Contratos de API claros</li>
                            <li>Manejo de errores consistente</li>
                        </ul>
                    </div>
                </div>

                <div class="step-card">
                    <div class="step-number">3</div>
                    <h3>Seleccionar el Stack Tecnol√≥gico</h3>
                    <p>Elige las tecnolog√≠as m√°s adecuadas para tu microservicio. Considera el lenguaje de programaci√≥n, framework, base de datos, y herramientas de comunicaci√≥n. La ventaja de los microservicios es que puedes elegir diferentes tecnolog√≠as para diferentes servicios.</p>
                    <div class="step-details">
                        <strong>Opciones comunes:</strong>
                        <ul>
                            <li>Lenguajes: Java, Python, Node.js, Go, .NET</li>
                            <li>Frameworks: Spring Boot, Express, Flask, FastAPI</li>
                            <li>Bases de datos: PostgreSQL, MongoDB, Redis</li>
                            <li>Mensajer√≠a: RabbitMQ, Kafka, NATS</li>
                        </ul>
                    </div>
                </div>

                <div class="step-card">
                    <div class="step-number">4</div>
                    <h3>Implementar la L√≥gica de Negocio</h3>
                    <p>Desarrolla la funcionalidad core del microservicio siguiendo principios de c√≥digo limpio y patrones de dise√±o. Implementa la l√≥gica de negocio de manera que sea testeable, mantenible y escalable.</p>
                    <div class="step-details">
                        <strong>Buenas pr√°cticas:</strong>
                        <ul>
                            <li>Separaci√≥n de responsabilidades (SRP)</li>
                            <li>Inyecci√≥n de dependencias</li>
                            <li>Patrones de dise√±o apropiados</li>
                            <li>C√≥digo testeable y documentado</li>
                        </ul>
                    </div>
                </div>

                <div class="step-card">
                    <div class="step-number">5</div>
                    <h3>Implementar la Persistencia de Datos</h3>
                    <p>Cada microservicio debe tener su propia base de datos para mantener el bajo acoplamiento. Implementa el patr√≥n <strong>Database per Service</strong> y define claramente el esquema de datos y las estrategias de migraci√≥n.</p>
                    <div class="step-details">
                        <strong>Aspectos importantes:</strong>
                        <ul>
                            <li>Base de datos independiente por servicio</li>
                            <li>Migraciones de esquema versionadas</li>
                            <li>Backup y recuperaci√≥n</li>
                            <li>Optimizaci√≥n de consultas</li>
                        </ul>
                    </div>
                </div>

                <div class="step-card">
                    <div class="step-number">6</div>
                    <h3>Configurar la Comunicaci√≥n entre Servicios</h3>
                    <p>Implementa mecanismos de comunicaci√≥n entre microservicios. Puedes usar comunicaci√≥n s√≠ncrona (REST, gRPC) o as√≠ncrona (mensajer√≠a con colas). Implementa patrones como Circuit Breaker para manejar fallos.</p>
                    <div class="step-details">
                        <strong>Patrones de comunicaci√≥n:</strong>
                        <ul>
                            <li>REST API (s√≠ncrono)</li>
                            <li>Message Queues (as√≠ncrono)</li>
                            <li>Event-driven architecture</li>
                            <li>Service mesh para comunicaci√≥n avanzada</li>
                        </ul>
                    </div>
                </div>

                <div class="step-card">
                    <div class="step-number">7</div>
                    <h3>Implementar Observabilidad</h3>
                    <p>A√±ade logging, m√©tricas y tracing distribuido para monitorear el comportamiento del microservicio. Utiliza herramientas como Prometheus, Grafana, ELK Stack o Jaeger para observabilidad completa.</p>
                    <div class="step-details">
                        <strong>Pilares de observabilidad:</strong>
                        <ul>
                            <li>Logging estructurado</li>
                            <li>M√©tricas de rendimiento</li>
                            <li>Distributed tracing</li>
                            <li>Health checks y alertas</li>
                        </ul>
                    </div>
                </div>

                <div class="step-card">
                    <div class="step-number">8</div>
                    <h3>Containerizar el Servicio</h3>
                    <p>Empaqueta tu microservicio en un contenedor Docker para asegurar consistencia entre entornos. Crea un Dockerfile optimizado y define las dependencias necesarias.</p>
                    <div class="step-details">
                        <strong>Elementos clave:</strong>
                        <ul>
                            <li>Dockerfile multi-stage para optimizaci√≥n</li>
                            <li>Im√°genes base ligeras (Alpine)</li>
                            <li>Variables de entorno para configuraci√≥n</li>
                            <li>Health checks en el contenedor</li>
                        </ul>
                    </div>
                </div>

                <div class="step-card">
                    <div class="step-number">9</div>
                    <h3>Configurar CI/CD</h3>
                    <p>Establece pipelines de integraci√≥n y despliegue continuo para automatizar pruebas, construcci√≥n y despliegue. Utiliza herramientas como Jenkins, GitLab CI, GitHub Actions o CircleCI.</p>
                    <div class="step-details">
                        <strong>Etapas del pipeline:</strong>
                        <ul>
                            <li>Build y compilaci√≥n</li>
                            <li>Tests automatizados</li>
                            <li>An√°lisis de c√≥digo</li>
                            <li>Despliegue automatizado</li>
                        </ul>
                    </div>
                </div>

                <div class="step-card">
                    <div class="step-number">10</div>
                    <h3>Desplegar y Monitorear</h3>
                    <p>Despliega tu microservicio en un orquestador de contenedores como Kubernetes. Configura auto-scaling, load balancing y monitoreo continuo. Establece alertas para detectar problemas proactivamente.</p>
                    <div class="step-details">
                        <strong>Aspectos del despliegue:</strong>
                        <ul>
                            <li>Orquestaci√≥n con Kubernetes</li>
                            <li>Auto-scaling horizontal</li>
                            <li>Load balancing y service discovery</li>
                            <li>Monitoreo y alertas en producci√≥n</li>
                        </ul>
                    </div>
                </div>
            </div>
        </div>
    </section>

    <!-- Arquitecturas -->
    <section id="arquitecturas" class="section">
        <div class="container">
            <h2 class="section-title">Arquitecturas de Microservicios</h2>
            
            <div class="architecture-intro">
                <p>Existen diversos patrones arquitect√≥nicos que se pueden aplicar al dise√±ar sistemas basados en microservicios. La elecci√≥n del patr√≥n adecuado depende de los requisitos espec√≠ficos del proyecto, la escala esperada y las necesidades del negocio.</p>
            </div>

            <div class="architecture-grid">
                <div class="architecture-card">
                    <h3>üî∑ API Gateway Pattern</h3>
                    <p>Un <strong>API Gateway</strong> act√∫a como un punto de entrada √∫nico para todos los clientes. Encapsula la arquitectura interna del sistema y proporciona una API adaptada a cada cliente. El gateway maneja solicitudes enrut√°ndolas a los microservicios apropiados, agregando resultados y traduciendo protocolos.</p>
                    <div class="architecture-benefits">
                        <strong>Beneficios:</strong>
                        <ul>
                            <li>Punto de entrada √∫nico simplificado</li>
                            <li>Reduce el n√∫mero de llamadas del cliente</li>
                            <li>Centraliza funciones transversales (autenticaci√≥n, logging)</li>
                            <li>A√≠sla a los clientes de cambios internos</li>
                        </ul>
                    </div>
                    <div class="architecture-use-cases">
                        <strong>Casos de uso:</strong> Aplicaciones m√≥viles, SPAs, sistemas con m√∫ltiples tipos de clientes
                    </div>
                </div>

                <div class="architecture-card">
                    <h3>üî∑ Event-Driven Architecture</h3>
                    <p>En una arquitectura <strong>orientada a eventos</strong>, los microservicios se comunican mediante la producci√≥n y consumo de eventos. Cuando un servicio realiza una acci√≥n significativa, publica un evento que otros servicios pueden consumir de manera as√≠ncrona.</p>
                    <div class="architecture-benefits">
                        <strong>Beneficios:</strong>
                        <ul>
                            <li>Bajo acoplamiento entre servicios</li>
                            <li>Alta escalabilidad y resiliencia</li>
                            <li>Procesamiento as√≠ncrono eficiente</li>
                            <li>Facilita la adici√≥n de nuevos servicios</li>
                        </ul>
                    </div>
                    <div class="architecture-use-cases">
                        <strong>Casos de uso:</strong> Sistemas de comercio electr√≥nico, procesamiento de pedidos, notificaciones en tiempo real
                    </div>
                </div>

                <div class="architecture-card">
                    <h3>üî∑ Service Mesh</h3>
                    <p>Un <strong>Service Mesh</strong> es una capa de infraestructura dedicada que controla la comunicaci√≥n servicio-a-servicio. Proporciona funcionalidades como descubrimiento de servicios, balanceo de carga, cifrado, autenticaci√≥n y observabilidad sin modificar el c√≥digo de los servicios.</p>
                    <div class="architecture-benefits">
                        <strong>Beneficios:</strong>
                        <ul>
                            <li>Gesti√≥n centralizada de comunicaci√≥n</li>
                            <li>Seguridad mejorada con mTLS</li>
                            <li>Observabilidad detallada del tr√°fico</li>
                            <li>Pol√≠ticas de retry y circuit breaking</li>
                        </ul>
                    </div>
                    <div class="architecture-use-cases">
                        <strong>Casos de uso:</strong> Sistemas complejos con muchos microservicios, entornos que requieren alta seguridad
                    </div>
                </div>

                <div class="architecture-card">
                    <h3>üî∑ CQRS (Command Query Responsibility Segregation)</h3>
                    <p><strong>CQRS</strong> separa las operaciones de lectura y escritura en modelos diferentes. Los comandos (escrituras) modifican el estado, mientras que las consultas (lecturas) recuperan datos. Esto permite optimizar cada modelo de manera independiente.</p>
                    <div class="architecture-benefits">
                        <strong>Beneficios:</strong>
                        <ul>
                            <li>Optimizaci√≥n independiente de lecturas y escrituras</li>
                            <li>Escalabilidad mejorada</li>
                            <li>Modelos de datos m√°s simples</li>
                            <li>Facilita Event Sourcing</li>
                        </ul>
                    </div>
                    <div class="architecture-use-cases">
                        <strong>Casos de uso:</strong> Sistemas con alta carga de lectura, aplicaciones que requieren auditor√≠a completa
                    </div>
                </div>

                <div class="architecture-card">
                    <h3>üî∑ Saga Pattern</h3>
                    <p>El patr√≥n <strong>Saga</strong> gestiona transacciones distribuidas dividiendo la transacci√≥n en una secuencia de transacciones locales. Cada transacci√≥n local actualiza la base de datos y publica un evento o mensaje. Si una transacci√≥n falla, se ejecutan transacciones compensatorias.</p>
                    <div class="architecture-benefits">
                        <strong>Beneficios:</strong>
                        <ul>
                            <li>Mantiene la consistencia en sistemas distribuidos</li>
                            <li>Evita bloqueos de larga duraci√≥n</li>
                            <li>Mayor disponibilidad del sistema</li>
                            <li>Gesti√≥n clara de fallos</li>
                        </ul>
                    </div>
                    <div class="architecture-use-cases">
                        <strong>Casos de uso:</strong> Procesamiento de pedidos, reservas, transacciones financieras distribuidas
                    </div>
                </div>

                <div class="architecture-card">
                    <h3>üî∑ Backend for Frontend (BFF)</h3>
                    <p>El patr√≥n <strong>BFF</strong> crea backends espec√≠ficos para cada tipo de frontend (web, m√≥vil, IoT). Cada BFF est√° optimizado para las necesidades particulares de su cliente, agregando y transformando datos de m√∫ltiples microservicios.</p>
                    <div class="architecture-benefits">
                        <strong>Beneficios:</strong>
                        <ul>
                            <li>APIs optimizadas por tipo de cliente</li>
                            <li>Reduce la l√≥gica en el frontend</li>
                            <li>Evoluci√≥n independiente de cada BFF</li>
                            <li>Mejor rendimiento para cada plataforma</li>
                        </ul>
                    </div>
                    <div class="architecture-use-cases">
                        <strong>Casos de uso:</strong> Aplicaciones con m√∫ltiples tipos de clientes (web, iOS, Android)
                    </div>
                </div>
            </div>

            <div class="architecture-image-section">
                <img src="images/software_architecture_patterns.png" alt="Patrones de Arquitectura de Software">
                <p class="image-caption">Diversos patrones de arquitectura de software aplicables a microservicios</p>
            </div>
        </div>
    </section>

    <!-- Stack Tecnol√≥gico -->
    <section id="stack-tecnologico" class="section section-alt">
        <div class="container">
            <h2 class="section-title">Stack Tecnol√≥gico para Microservicios</h2>
            
            <div class="stack-intro">
                <p>El ecosistema de microservicios requiere una variedad de tecnolog√≠as que trabajan en conjunto para proporcionar desarrollo, despliegue, comunicaci√≥n, monitoreo y gesti√≥n eficientes. A continuaci√≥n se presentan las categor√≠as principales y las tecnolog√≠as m√°s utilizadas en cada una.</p>
            </div>

            <div class="stack-grid">
                <div class="stack-category">
                    <h3>üíª Lenguajes y Frameworks</h3>
                    <div class="tech-list">
                        <div class="tech-item">
                            <strong>Java / Spring Boot</strong>
                            <p>Framework robusto y maduro para construir microservicios empresariales. Ofrece inyecci√≥n de dependencias, configuraci√≥n externalizada y amplio ecosistema.</p>
                        </div>
                        <div class="tech-item">
                            <strong>Node.js / Express</strong>
                            <p>Ideal para microservicios de alto rendimiento con I/O intensivo. Ecosistema npm rico y excelente para APIs RESTful.</p>
                        </div>
                        <div class="tech-item">
                            <strong>Python / FastAPI</strong>
                            <p>Framework moderno con validaci√≥n autom√°tica, documentaci√≥n interactiva y alto rendimiento. Excelente para APIs y servicios de datos.</p>
                        </div>
                        <div class="tech-item">
                            <strong>Go</strong>
                            <p>Lenguaje compilado con excelente rendimiento y concurrencia nativa. Ideal para servicios de alto tr√°fico y baja latencia.</p>
                        </div>
                        <div class="tech-item">
                            <strong>.NET Core / ASP.NET</strong>
                            <p>Framework multiplataforma de Microsoft con excelente rendimiento y herramientas de desarrollo.</p>
                        </div>
                    </div>
                </div>

                <div class="stack-category">
                    <h3>üóÑÔ∏è Bases de Datos</h3>
                    <div class="tech-list">
                        <div class="tech-item">
                            <strong>PostgreSQL</strong>
                            <p>Base de datos relacional robusta con soporte para JSON, transacciones ACID y extensiones avanzadas.</p>
                        </div>
                        <div class="tech-item">
                            <strong>MongoDB</strong>
                            <p>Base de datos NoSQL orientada a documentos, flexible y escalable horizontalmente.</p>
                        </div>
                        <div class="tech-item">
                            <strong>Redis</strong>
                            <p>Almac√©n de datos en memoria para cach√©, sesiones y colas de mensajes de alta velocidad.</p>
                        </div>
                        <div class="tech-item">
                            <strong>Cassandra</strong>
                            <p>Base de datos distribuida dise√±ada para manejar grandes vol√∫menes de datos con alta disponibilidad.</p>
                        </div>
                    </div>
                </div>

                <div class="stack-category">
                    <h3>üì° Comunicaci√≥n y Mensajer√≠a</h3>
                    <div class="tech-list">
                        <div class="tech-item">
                            <strong>REST / HTTP</strong>
                            <p>Protocolo est√°ndar para comunicaci√≥n s√≠ncrona entre servicios mediante APIs RESTful.</p>
                        </div>
                        <div class="tech-item">
                            <strong>gRPC</strong>
                            <p>Framework RPC de alto rendimiento que usa Protocol Buffers, ideal para comunicaci√≥n servicio-a-servicio.</p>
                        </div>
                        <div class="tech-item">
                            <strong>Apache Kafka</strong>
                            <p>Plataforma de streaming distribuido para procesamiento de eventos en tiempo real y mensajer√≠a as√≠ncrona.</p>
                        </div>
                        <div class="tech-item">
                            <strong>RabbitMQ</strong>
                            <p>Message broker que implementa AMQP, ideal para patrones de mensajer√≠a complejos.</p>
                        </div>
                        <div class="tech-item">
                            <strong>NATS</strong>
                            <p>Sistema de mensajer√≠a ligero y de alto rendimiento para arquitecturas cloud-native.</p>
                        </div>
                    </div>
                </div>

                <div class="stack-category">
                    <h3>üê≥ Containerizaci√≥n y Orquestaci√≥n</h3>
                    <div class="tech-list">
                        <div class="tech-item">
                            <strong>Docker</strong>
                            <p>Plataforma de containerizaci√≥n que empaqueta aplicaciones con sus dependencias para consistencia entre entornos.</p>
                        </div>
                        <div class="tech-item">
                            <strong>Kubernetes</strong>
                            <p>Orquestador de contenedores que automatiza despliegue, escalado y gesti√≥n de aplicaciones containerizadas.</p>
                        </div>
                        <div class="tech-item">
                            <strong>Docker Compose</strong>
                            <p>Herramienta para definir y ejecutar aplicaciones multi-contenedor, ideal para desarrollo local.</p>
                        </div>
                        <div class="tech-item">
                            <strong>Helm</strong>
                            <p>Gestor de paquetes para Kubernetes que simplifica el despliegue de aplicaciones complejas.</p>
                        </div>
                    </div>
                </div>

                <div class="stack-category">
                    <h3>üîç Observabilidad y Monitoreo</h3>
                    <div class="tech-list">
                        <div class="tech-item">
                            <strong>Prometheus</strong>
                            <p>Sistema de monitoreo y alertas con modelo de datos de series temporales, ideal para m√©tricas.</p>
                        </div>
                        <div class="tech-item">
                            <strong>Grafana</strong>
                            <p>Plataforma de visualizaci√≥n y an√°lisis para crear dashboards interactivos de m√©tricas.</p>
                        </div>
                        <div class="tech-item">
                            <strong>ELK Stack (Elasticsearch, Logstash, Kibana)</strong>
                            <p>Suite completa para b√∫squeda, an√°lisis y visualizaci√≥n de logs en tiempo real.</p>
                        </div>
                        <div class="tech-item">
                            <strong>Jaeger</strong>
                            <p>Sistema de tracing distribuido para monitorear y troubleshoot transacciones en sistemas distribuidos.</p>
                        </div>
                        <div class="tech-item">
                            <strong>Zipkin</strong>
                            <p>Sistema de tracing distribuido que ayuda a recopilar datos de timing para troubleshooting de latencia.</p>
                        </div>
                    </div>
                </div>

                <div class="stack-category">
                    <h3>üîê API Gateway y Service Mesh</h3>
                    <div class="tech-list">
                        <div class="tech-item">
                            <strong>Kong</strong>
                            <p>API Gateway de c√≥digo abierto con plugins para autenticaci√≥n, rate limiting y transformaci√≥n.</p>
                        </div>
                        <div class="tech-item">
                            <strong>NGINX</strong>
                            <p>Servidor web y proxy inverso que puede funcionar como API Gateway y load balancer.</p>
                        </div>
                        <div class="tech-item">
                            <strong>Istio</strong>
                            <p>Service mesh que proporciona gesti√≥n de tr√°fico, seguridad y observabilidad para microservicios.</p>
                        </div>
                        <div class="tech-item">
                            <strong>Linkerd</strong>
                            <p>Service mesh ligero y f√°cil de usar para Kubernetes con enfoque en simplicidad.</p>
                        </div>
                    </div>
                </div>

                <div class="stack-category">
                    <h3>üöÄ CI/CD</h3>
                    <div class="tech-list">
                        <div class="tech-item">
                            <strong>Jenkins</strong>
                            <p>Servidor de automatizaci√≥n de c√≥digo abierto con amplio ecosistema de plugins.</p>
                        </div>
                        <div class="tech-item">
                            <strong>GitLab CI/CD</strong>
                            <p>Plataforma integrada con control de versiones para pipelines de CI/CD.</p>
                        </div>
                        <div class="tech-item">
                            <strong>GitHub Actions</strong>
                            <p>Automatizaci√≥n de workflows directamente desde repositorios de GitHub.</p>
                        </div>
                        <div class="tech-item">
                            <strong>ArgoCD</strong>
                            <p>Herramienta de continuous delivery declarativa para Kubernetes con enfoque GitOps.</p>
                        </div>
                    </div>
                </div>

                <div class="stack-category">
                    <h3>üîß Service Discovery y Configuration</h3>
                    <div class="tech-list">
                        <div class="tech-item">
                            <strong>Consul</strong>
                            <p>Soluci√≥n para service discovery, configuraci√≥n y segmentaci√≥n de servicios.</p>
                        </div>
                        <div class="tech-item">
                            <strong>Eureka</strong>
                            <p>Servicio de descubrimiento de Netflix OSS, popular en ecosistemas Spring Cloud.</p>
                        </div>
                        <div class="tech-item">
                            <strong>etcd</strong>
                            <p>Almac√©n de clave-valor distribuido para configuraci√≥n y service discovery.</p>
                        </div>
                        <div class="tech-item">
                            <strong>Spring Cloud Config</strong>
                            <p>Servidor de configuraci√≥n centralizada para aplicaciones distribuidas.</p>
                        </div>
                    </div>
                </div>
            </div>

            <div class="stack-image-section">
                <img src="images/microservices_technologies_stack.jpg" alt="Stack Tecnol√≥gico de Microservicios">
                <p class="image-caption">Ecosistema tecnol√≥gico completo para arquitecturas de microservicios</p>
            </div>
        </div>
    </section>

    <!-- Ciclo de Vida -->
    <section id="ciclo-vida" class="section">
        <div class="container">
            <h2 class="section-title">Ciclo de Vida del Software en Microservicios</h2>
            
            <div class="lifecycle-intro">
                <p>El ciclo de vida del desarrollo de software en arquitecturas de microservicios sigue principios similares al desarrollo tradicional, pero con adaptaciones espec√≠ficas para manejar la naturaleza distribuida y la independencia de los servicios. El enfoque DevOps y la automatizaci√≥n son fundamentales en cada fase.</p>
            </div>

            <div class="lifecycle-phases">
                <div class="lifecycle-phase">
                    <div class="phase-header">
                        <div class="phase-icon">üìã</div>
                        <h3>1. Planificaci√≥n y An√°lisis</h3>
                    </div>
                    <div class="phase-content">
                        <p>En esta fase inicial se definen los requisitos del negocio y se identifican los bounded contexts que se convertir√°n en microservicios. Se realiza el an√°lisis de dominio utilizando t√©cnicas de Domain-Driven Design.</p>
                        <div class="phase-activities">
                            <strong>Actividades principales:</strong>
                            <ul>
                                <li>Identificaci√≥n de requisitos funcionales y no funcionales</li>
                                <li>An√°lisis de dominio y bounded contexts</li>
                                <li>Definici√≥n de la estrategia de descomposici√≥n</li>
                                <li>Planificaci√≥n de la arquitectura general</li>
                                <li>Identificaci√≥n de dependencias entre servicios</li>
                            </ul>
                        </div>
                        <div class="phase-deliverables">
                            <strong>Entregables:</strong> Documento de requisitos, diagrama de bounded contexts, arquitectura de alto nivel
                        </div>
                    </div>
                </div>

                <div class="lifecycle-phase">
                    <div class="phase-header">
                        <div class="phase-icon">üé®</div>
                        <h3>2. Dise√±o</h3>
                    </div>
                    <div class="phase-content">
                        <p>Se dise√±a la arquitectura detallada de cada microservicio, incluyendo APIs, modelos de datos, patrones de comunicaci√≥n y estrategias de resiliencia. Se definen los contratos entre servicios y las interfaces p√∫blicas.</p>
                        <div class="phase-activities">
                            <strong>Actividades principales:</strong>
                            <ul>
                                <li>Dise√±o de APIs RESTful o GraphQL</li>
                                <li>Definici√≥n de esquemas de base de datos</li>
                                <li>Selecci√≥n de patrones arquitect√≥nicos (API Gateway, Event-Driven, etc.)</li>
                                <li>Dise√±o de estrategias de comunicaci√≥n (s√≠ncrona/as√≠ncrona)</li>
                                <li>Definici√≥n de pol√≠ticas de seguridad y autenticaci√≥n</li>
                                <li>Dise√±o de estrategias de resiliencia (Circuit Breaker, Retry)</li>
                            </ul>
                        </div>
                        <div class="phase-deliverables">
                            <strong>Entregables:</strong> Especificaciones de API (OpenAPI), diagramas de arquitectura, modelos de datos
                        </div>
                    </div>
                </div>

                <div class="lifecycle-phase">
                    <div class="phase-header">
                        <div class="phase-icon">‚öôÔ∏è</div>
                        <h3>3. Desarrollo</h3>
                    </div>
                    <div class="phase-content">
                        <p>Los equipos desarrollan los microservicios de manera independiente siguiendo las especificaciones de dise√±o. Se implementa la l√≥gica de negocio, la persistencia de datos y la comunicaci√≥n entre servicios.</p>
                        <div class="phase-activities">
                            <strong>Actividades principales:</strong>
                            <ul>
                                <li>Implementaci√≥n de la l√≥gica de negocio</li>
                                <li>Desarrollo de APIs y endpoints</li>
                                <li>Implementaci√≥n de persistencia de datos</li>
                                <li>Integraci√≥n con otros servicios</li>
                                <li>Implementaci√≥n de logging y m√©tricas</li>
                                <li>Desarrollo de tests unitarios y de integraci√≥n</li>
                            </ul>
                        </div>
                        <div class="phase-deliverables">
                            <strong>Entregables:</strong> C√≥digo fuente, tests automatizados, documentaci√≥n t√©cnica
                        </div>
                    </div>
                </div>

                <div class="lifecycle-phase">
                    <div class="phase-header">
                        <div class="phase-icon">üß™</div>
                        <h3>4. Testing</h3>
                    </div>
                    <div class="phase-content">
                        <p>Se realizan m√∫ltiples niveles de testing para asegurar la calidad del software. En microservicios, el testing es m√°s complejo debido a la naturaleza distribuida del sistema.</p>
                        <div class="phase-activities">
                            <strong>Tipos de testing:</strong>
                            <ul>
                                <li><strong>Unit Testing:</strong> Pruebas de componentes individuales</li>
                                <li><strong>Integration Testing:</strong> Pruebas de interacci√≥n entre servicios</li>
                                <li><strong>Contract Testing:</strong> Validaci√≥n de contratos entre servicios</li>
                                <li><strong>End-to-End Testing:</strong> Pruebas de flujos completos del sistema</li>
                                <li><strong>Performance Testing:</strong> Pruebas de carga y estr√©s</li>
                                <li><strong>Chaos Engineering:</strong> Pruebas de resiliencia y recuperaci√≥n</li>
                            </ul>
                        </div>
                        <div class="phase-deliverables">
                            <strong>Entregables:</strong> Reportes de testing, cobertura de c√≥digo, resultados de performance
                        </div>
                    </div>
                </div>

                <div class="lifecycle-phase">
                    <div class="phase-header">
                        <div class="phase-icon">üöÄ</div>
                        <h3>5. Despliegue</h3>
                    </div>
                    <div class="phase-content">
                        <p>Los microservicios se despliegan de manera independiente utilizando pipelines de CI/CD automatizados. Se utilizan contenedores y orquestadores para gestionar el despliegue en diferentes entornos.</p>
                        <div class="phase-activities">
                            <strong>Actividades principales:</strong>
                            <ul>
                                <li>Containerizaci√≥n con Docker</li>
                                <li>Configuraci√≥n de pipelines CI/CD</li>
                                <li>Despliegue en Kubernetes u otro orquestador</li>
                                <li>Configuraci√≥n de auto-scaling y load balancing</li>
                                <li>Implementaci√≥n de estrategias de despliegue (Blue-Green, Canary)</li>
                                <li>Configuraci√≥n de service mesh si es necesario</li>
                            </ul>
                        </div>
                        <div class="phase-deliverables">
                            <strong>Entregables:</strong> Im√°genes Docker, manifiestos Kubernetes, pipelines configurados
                        </div>
                    </div>
                </div>

                <div class="lifecycle-phase">
                    <div class="phase-header">
                        <div class="phase-icon">üìä</div>
                        <h3>6. Monitoreo y Mantenimiento</h3>
                    </div>
                    <div class="phase-content">
                        <p>Una vez en producci√≥n, los microservicios requieren monitoreo continuo para detectar problemas, optimizar rendimiento y asegurar disponibilidad. Se implementan los tres pilares de observabilidad: logs, m√©tricas y tracing.</p>
                        <div class="phase-activities">
                            <strong>Actividades principales:</strong>
                            <ul>
                                <li>Monitoreo de m√©tricas con Prometheus/Grafana</li>
                                <li>Agregaci√≥n y an√°lisis de logs con ELK Stack</li>
                                <li>Tracing distribuido con Jaeger o Zipkin</li>
                                <li>Configuraci√≥n de alertas proactivas</li>
                                <li>An√°lisis de rendimiento y optimizaci√≥n</li>
                                <li>Gesti√≥n de incidentes y troubleshooting</li>
                                <li>Actualizaciones y parches de seguridad</li>
                            </ul>
                        </div>
                        <div class="phase-deliverables">
                            <strong>Entregables:</strong> Dashboards de monitoreo, reportes de incidentes, planes de optimizaci√≥n
                        </div>
                    </div>
                </div>

                <div class="lifecycle-phase">
                    <div class="phase-header">
                        <div class="phase-icon">üîÑ</div>
                        <h3>7. Evoluci√≥n y Mejora Continua</h3>
                    </div>
                    <div class="phase-content">
                        <p>Los microservicios evolucionan continuamente bas√°ndose en feedback de usuarios, m√©tricas de rendimiento y nuevos requisitos del negocio. La arquitectura permite evoluci√≥n independiente de cada servicio.</p>
                        <div class="phase-activities">
                            <strong>Actividades principales:</strong>
                            <ul>
                                <li>An√°lisis de feedback de usuarios</li>
                                <li>Identificaci√≥n de mejoras basadas en m√©tricas</li>
                                <li>Refactorizaci√≥n y optimizaci√≥n de c√≥digo</li>
                                <li>Implementaci√≥n de nuevas funcionalidades</li>
                                <li>Versionado de APIs y estrategias de deprecaci√≥n</li>
                                <li>Evaluaci√≥n de nuevas tecnolog√≠as</li>
                            </ul>
                        </div>
                        <div class="phase-deliverables">
                            <strong>Entregables:</strong> Nuevas versiones de servicios, documentaci√≥n actualizada, roadmap de producto
                        </div>
                    </div>
                </div>
            </div>

            <div class="lifecycle-diagram">
                <h3>Ciclo Continuo DevOps</h3>
                <p>En arquitecturas de microservicios, el ciclo de vida sigue un modelo continuo donde el desarrollo, testing, despliegue y monitoreo ocurren de manera iterativa y automatizada. Este enfoque DevOps permite entregas frecuentes y r√°pida respuesta a cambios.</p>
                <div class="devops-principles">
                    <div class="principle-card">
                        <h4>ü§ù Colaboraci√≥n</h4>
                        <p>Equipos multifuncionales trabajan juntos en el ciclo completo</p>
                    </div>
                    <div class="principle-card">
                        <h4>ü§ñ Automatizaci√≥n</h4>
                        <p>Pipelines automatizados para build, test y deploy</p>
                    </div>
                    <div class="principle-card">
                        <h4>üìà Mejora Continua</h4>
                        <p>Iteraciones frecuentes basadas en feedback y m√©tricas</p>
                    </div>
                    <div class="principle-card">
                        <h4>üîç Monitoreo</h4>
                        <p>Observabilidad completa del sistema en producci√≥n</p>
                    </div>
                </div>
            </div>
        </div>
    </section>

    <!-- Quiz -->
    <section id="quiz" class="section section-alt">
        <div class="container">
            <h2 class="section-title">Quiz: Eval√∫a tus Conocimientos</h2>
            
            <div class="quiz-intro">
                <p>Pon a prueba lo que has aprendido sobre microservicios con este quiz interactivo. Selecciona la respuesta correcta para cada pregunta y recibe feedback inmediato.</p>
            </div>

            <div id="quiz-container" class="quiz-container">
                <div class="quiz-question active" data-question="1">
                    <h3>Pregunta 1 de 10</h3>
                    <p class="question-text">¬øCu√°l es la principal diferencia entre una arquitectura monol√≠tica y una de microservicios?</p>
                    <div class="quiz-options">
                        <button class="quiz-option" data-answer="wrong">Los microservicios son m√°s lentos que los monolitos</button>
                        <button class="quiz-option" data-answer="correct">Los microservicios permiten despliegue y escalado independiente de cada componente</button>
                        <button class="quiz-option" data-answer="wrong">Los monolitos no pueden usar bases de datos</button>
                        <button class="quiz-option" data-answer="wrong">Los microservicios solo funcionan con Java</button>
                    </div>
                    <div class="quiz-feedback"></div>
                </div>

                <div class="quiz-question" data-question="2">
                    <h3>Pregunta 2 de 10</h3>
                    <p class="question-text">¬øQu√© patr√≥n arquitect√≥nico proporciona un punto de entrada √∫nico para todos los clientes?</p>
                    <div class="quiz-options">
                        <button class="quiz-option" data-answer="wrong">Service Mesh</button>
                        <button class="quiz-option" data-answer="correct">API Gateway</button>
                        <button class="quiz-option" data-answer="wrong">CQRS</button>
                        <button class="quiz-option" data-answer="wrong">Saga Pattern</button>
                    </div>
                    <div class="quiz-feedback"></div>
                </div>

                <div class="quiz-question" data-question="3">
                    <h3>Pregunta 3 de 10</h3>
                    <p class="question-text">¬øCu√°l es el principio fundamental del patr√≥n "Database per Service"?</p>
                    <div class="quiz-options">
                        <button class="quiz-option" data-answer="wrong">Todos los servicios comparten la misma base de datos</button>
                        <button class="quiz-option" data-answer="correct">Cada microservicio tiene su propia base de datos independiente</button>
                        <button class="quiz-option" data-answer="wrong">No se deben usar bases de datos en microservicios</button>
                        <button class="quiz-option" data-answer="wrong">Solo se puede usar MongoDB</button>
                    </div>
                    <div class="quiz-feedback"></div>
                </div>

                <div class="quiz-question" data-question="4">
                    <h3>Pregunta 4 de 10</h3>
                    <p class="question-text">¬øQu√© herramienta se utiliza com√∫nmente para orquestar contenedores en producci√≥n?</p>
                    <div class="quiz-options">
                        <button class="quiz-option" data-answer="wrong">Git</button>
                        <button class="quiz-option" data-answer="wrong">Jenkins</button>
                        <button class="quiz-option" data-answer="correct">Kubernetes</button>
                        <button class="quiz-option" data-answer="wrong">MongoDB</button>
                    </div>
                    <div class="quiz-feedback"></div>
                </div>

                <div class="quiz-question" data-question="5">
                    <h3>Pregunta 5 de 10</h3>
                    <p class="question-text">¬øCu√°les son los tres pilares de la observabilidad?</p>
                    <div class="quiz-options">
                        <button class="quiz-option" data-answer="wrong">Frontend, Backend, Database</button>
                        <button class="quiz-option" data-answer="correct">Logs, M√©tricas, Tracing</button>
                        <button class="quiz-option" data-answer="wrong">Docker, Kubernetes, Jenkins</button>
                        <button class="quiz-option" data-answer="wrong">REST, gRPC, GraphQL</button>
                    </div>
                    <div class="quiz-feedback"></div>
                </div>

                <div class="quiz-question" data-question="6">
                    <h3>Pregunta 6 de 10</h3>
                    <p class="question-text">¬øQu√© patr√≥n se utiliza para gestionar transacciones distribuidas en microservicios?</p>
                    <div class="quiz-options">
                        <button class="quiz-option" data-answer="wrong">API Gateway</button>
                        <button class="quiz-option" data-answer="wrong">Service Mesh</button>
                        <button class="quiz-option" data-answer="correct">Saga Pattern</button>
                        <button class="quiz-option" data-answer="wrong">Singleton Pattern</button>
                    </div>
                    <div class="quiz-feedback"></div>
                </div>

                <div class="quiz-question" data-question="7">
                    <h3>Pregunta 7 de 10</h3>
                    <p class="question-text">¬øQu√© protocolo de comunicaci√≥n es m√°s eficiente para comunicaci√≥n servicio-a-servicio?</p>
                    <div class="quiz-options">
                        <button class="quiz-option" data-answer="wrong">FTP</button>
                        <button class="quiz-option" data-answer="correct">gRPC</button>
                        <button class="quiz-option" data-answer="wrong">SMTP</button>
                        <button class="quiz-option" data-answer="wrong">Telnet</button>
                    </div>
                    <div class="quiz-feedback"></div>
                </div>

                <div class="quiz-question" data-question="8">
                    <h3>Pregunta 8 de 10</h3>
                    <p class="question-text">¬øQu√© significa CQRS?</p>
                    <div class="quiz-options">
                        <button class="quiz-option" data-answer="wrong">Continuous Query and Response System</button>
                        <button class="quiz-option" data-answer="correct">Command Query Responsibility Segregation</button>
                        <button class="quiz-option" data-answer="wrong">Cloud Quality Resource Service</button>
                        <button class="quiz-option" data-answer="wrong">Container Query Routing System</button>
                    </div>
                    <div class="quiz-feedback"></div>
                </div>

                <div class="quiz-question" data-question="9">
                    <h3>Pregunta 9 de 10</h3>
                    <p class="question-text">¬øCu√°l es una ventaja principal de usar Docker en microservicios?</p>
                    <div class="quiz-options">
                        <button class="quiz-option" data-answer="wrong">Hace que el c√≥digo sea m√°s r√°pido</button>
                        <button class="quiz-option" data-answer="correct">Proporciona consistencia entre entornos de desarrollo y producci√≥n</button>
                        <button class="quiz-option" data-answer="wrong">Elimina la necesidad de testing</button>
                        <button class="quiz-option" data-answer="wrong">Reemplaza a Kubernetes</button>
                    </div>
                    <div class="quiz-feedback"></div>
                </div>

                <div class="quiz-question" data-question="10">
                    <h3>Pregunta 10 de 10</h3>
                    <p class="question-text">¬øQu√© herramienta se utiliza para tracing distribuido?</p>
                    <div class="quiz-options">
                        <button class="quiz-option" data-answer="wrong">Docker</button>
                        <button class="quiz-option" data-answer="wrong">Redis</button>
                        <button class="quiz-option" data-answer="correct">Jaeger</button>
                        <button class="quiz-option" data-answer="wrong">PostgreSQL</button>
                    </div>
                    <div class="quiz-feedback"></div>
                </div>

                <div id="quiz-results" class="quiz-results" style="display: none;">
                    <h3>¬°Quiz Completado!</h3>
                    <div class="results-content">
                        <div class="score-display">
                            <span class="score-number" id="final-score">0</span>
                            <span class="score-total">/ 10</span>
                        </div>
                        <p id="results-message"></p>
                        <button id="restart-quiz" class="btn-primary">Reintentar Quiz</button>
                    </div>
                </div>
            </div>

            <div class="quiz-controls">
                <button id="prev-question" class="btn-secondary" style="display: none;">Anterior</button>
                <button id="next-question" class="btn-secondary" style="display: none;">Siguiente</button>
            </div>
        </div>
    </section>

    <!-- Footer -->
    <footer class="footer">
        <div class="container">
            <div class="footer-content">
                <div class="footer-section">
                    <h3>Microservicios</h3>
                    <p>Gu√≠a completa sobre arquitecturas de microservicios en ingenier√≠a de software.</p>
                </div>
                <div class="footer-section">
                    <h4>Secciones</h4>
                    <ul>
                        <li><a href="#introduccion">Introducci√≥n</a></li>
                        <li><a href="#paso-a-paso">Paso a Paso</a></li>
                        <li><a href="#arquitecturas">Arquitecturas</a></li>
                        <li><a href="#stack-tecnologico">Stack Tecnol√≥gico</a></li>
                    </ul>
                </div>
                <div class="footer-section">
                    <h4>Recursos</h4>
                    <ul>
                        <li><a href="#ciclo-vida">Ciclo de Vida</a></li>
                        <li><a href="#quiz">Quiz</a></li>
                    </ul>
                </div>
            </div>
            <div class="footer-bottom">
                <p>&copy; 2025 Microservicios - Gu√≠a Educativa. Todos los derechos reservados.</p>
            </div>
        </div>
    </footer>

    <script src="script.js"></script>
</body>
</html>

